name: Criar Sub-Issues a partir de Story (v2)

on:
  issues:
    types: [opened, labeled]

jobs:
  create-subissues:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.labels.*.name, 'story') || contains(github.event.issue.title, '[Story]')
    steps:
      - name: Criar sub-issues e relacionamentos
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const parentNumber = issue.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            console.log(`Processando Story #${parentNumber}: ${issue.title}`);

            // FunÃ§Ã£o auxiliar para extrair seÃ§Ãµes
            const extract = (label) => {
              const regex = new RegExp(`### ${label}[\\s\\S]*?\\n([\\s\\S]*?)(?=\\n###|$)`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : null;
            };

            // Extrair lista de sub-issues do corpo da issue
            let subissues = [];
            
            // Procurar por seÃ§Ã£o especÃ­fica de sub-issues
            const subissuesSection = extract('Sub-issues a serem criadas') || 
                                   extract('Sub-issues') || 
                                   extract('Tarefas') ||
                                   extract('Tasks');
            
            if (subissuesSection) {
              subissues = subissuesSection.split('\n')
                .map(line => line.trim())
                .filter(line => line.startsWith('- [ ]') || line.startsWith('-'))
                .map(line => line.replace(/^-\s*\[\s*\]\s*/, '').replace(/^-\s*/, '').trim())
                .filter(line => line.length > 0);
            }

            // Se nÃ£o encontrou seÃ§Ã£o especÃ­fica, procurar por checkboxes no corpo todo
            if (subissues.length === 0) {
              const checkboxRegex = /-\s*\[\s*\]\s*(.+)/g;
              let match;
              while ((match = checkboxRegex.exec(body)) !== null) {
                const taskText = match[1].trim();
                if (taskText.length > 0) {
                  subissues.push(taskText);
                }
              }
            }

            console.log(`Encontradas ${subissues.length} sub-issues para criar:`, subissues);

            if (subissues.length === 0) {
              console.log('Nenhuma sub-issue encontrada para criar. Finalizando.');
              return;
            }

            // Determinar tipo das sub-issues baseado no tipo do story
            let tipoSubIssue = 'Task';
            if (issue.title.includes('[Story]')) {
              tipoSubIssue = 'Feature';
            } else if (issue.title.includes('[Feature]')) {
              tipoSubIssue = 'Task';
            }

            // Extrair informaÃ§Ãµes adicionais se disponÃ­veis
            const prioridade = extract('Prioridade');
            const sprint = extract('Sprint') || extract('Sprint ou perÃ­odo de execuÃ§Ã£o');
            const tipoImplementacao = extract('Tipo de implementaÃ§Ã£o');

            // Buscar milestone se especificado
            let milestoneId = null;
            if (sprint) {
              try {
                const milestones = await github.rest.issues.listMilestones({ 
                  owner, 
                  repo,
                  state: 'open'
                });
                const found = milestones.data.find(m => 
                  m.title.toLowerCase().includes(sprint.toLowerCase()) || 
                  sprint.toLowerCase().includes(m.title.toLowerCase())
                );
                if (found) {
                  milestoneId = found.number;
                  console.log(`Milestone encontrada: ${found.title} (ID: ${milestoneId})`);
                }
              } catch (error) {
                console.log('Erro ao buscar milestones:', error);
              }
            }

            // Montar labels para as sub-issues
            const labels = [tipoSubIssue.toLowerCase()];
            if (prioridade) {
              labels.push(`prioridade-${prioridade.toLowerCase()}`);
            }
            if (tipoImplementacao) {
              labels.push(tipoImplementacao.toLowerCase());
            }
            labels.push('sub-issue'); // Label para identificar como sub-issue

            const createdIssues = [];
            const projectItems = [];

            // Buscar informaÃ§Ãµes do projeto GitHub Projects v2
            let projectV2Id = null;
            try {
              const projectQuery = `
                query($owner: String!) {
                  organization(login: $owner) {
                    projectsV2(first: 10) {
                      nodes {
                        id
                        title
                        number
                        url
                      }
                    }
                  }
                }
              `;
              
              const projectResult = await github.graphql(projectQuery, { owner });
              if (projectResult.organization?.projectsV2?.nodes?.length > 0) {
                projectV2Id = projectResult.organization.projectsV2.nodes[0].id;
                console.log(`Projeto GitHub Projects v2 encontrado: ${projectV2Id}`);
              }
            } catch (error) {
              console.log('Projeto nÃ£o encontrado ou erro:', error.message);
            }

            // Criar cada sub-issue
            for (let i = 0; i < subissues.length; i++) {
              const taskTitle = subissues[i];
              
              try {
                const issuePayload = {
                  owner,
                  repo,
                  title: `[${tipoSubIssue}] ${taskTitle}`,
                  body: `### DescriÃ§Ã£o
Esta Ã© uma sub-issue do Story #${parentNumber}.

**Story Pai:** #${parentNumber} - ${issue.title}

### CritÃ©rios de Aceite
- [ ] Implementar funcionalidade conforme especificado
- [ ] Testes unitÃ¡rios implementados
- [ ] DocumentaÃ§Ã£o atualizada

### Relacionamento
- **Tipo:** Sub-issue
- **Pai:** #${parentNumber}
- **Ãndice:** ${i + 1} de ${subissues.length}`,
                  labels: labels
                };

                if (milestoneId) {
                  issuePayload.milestone = milestoneId;
                }

                console.log(`Criando sub-issue ${i + 1}/${subissues.length}: ${taskTitle}`);
                const newIssue = await github.rest.issues.create(issuePayload);
                
                console.log(`Sub-issue criada: #${newIssue.data.number}`);
                createdIssues.push({
                  number: newIssue.data.number,
                  title: taskTitle,
                  url: newIssue.data.html_url,
                  nodeId: newIssue.data.node_id
                });

                // Se temos projeto v2, tentar adicionar as issues
                if (projectV2Id) {
                  try {
                    const addToProjectMutation = `
                      mutation($projectId: ID!, $contentId: ID!) {
                        addProjectV2ItemByContentId(input: {
                          projectId: $projectId,
                          contentId: $contentId
                        }) {
                          item {
                            id
                          }
                        }
                      }
                    `;

                    const result = await github.graphql(addToProjectMutation, {
                      projectId: projectV2Id,
                      contentId: newIssue.data.node_id
                    });

                    if (result.addProjectV2ItemByContentId?.item?.id) {
                      console.log(`Sub-issue #${newIssue.data.number} adicionada ao projeto`);
                      projectItems.push({
                        issueNumber: newIssue.data.number,
                        projectItemId: result.addProjectV2ItemByContentId.item.id
                      });
                    }
                  } catch (projectError) {
                    console.log(`Erro ao adicionar #${newIssue.data.number} ao projeto:`, projectError);
                  }
                }

                // Criar relacionamento parent/child no GitHub Projects v2
                if (projectV2Id) {
                  try {
                    const parentItemId = await getProjectItemId(projectV2Id, parentNumber);
                    const childItemId = await getProjectItemId(projectV2Id, newIssue.data.number);

                    if (parentItemId && childItemId) {
                      const linkMutation = `
                        mutation($projectId: ID!, $parentId: ID!, $childId: ID!) {
                          updateProjectV2ItemFieldValue(input: {
                            projectId: $projectId,
                            itemId: $childId,
                            fieldId: "parent",
                            value: {
                              singleSelectOptionId: $parentId
                            }
                          }) {
                            projectV2Item {
                              id
                            }
                          }
                        }
                      `;

                      await github.graphql(linkMutation, {
                        projectId: projectV2Id,
                        parentId: parentItemId,
                        childId: childItemId
                      });

                      console.log(`Relacionamento parent/child criado entre #${parentNumber} e #${newIssue.data.number}`);
                    }
                  } catch (error) {
                    console.log(`Erro ao criar relacionamento parent/child: ${error.message}`);
                  }
                }

                // Pausa entre criaÃ§Ãµes para evitar rate limiting
                await new Promise(resolve => setTimeout(resolve, 1000));

              } catch (error) {
                console.log(`Erro ao criar sub-issue "${taskTitle}":`, error);
              }
            }

            // Atualizar o story com checklist das sub-issues criadas
            if (createdIssues.length > 0) {
              const checklistItems = createdIssues.map(item => 
                `- [ ] #${item.number} ${item.title}`
              ).join('\n');

              const statusSummary = `### ðŸ“‹ Sub-issues Criadas
*Progresso: 0 de ${createdIssues.length} concluÃ­das*

${checklistItems}

---
**Criado automaticamente em:** ${new Date().toLocaleString('pt-BR')}
**Sub-issues do tipo:** ${tipoSubIssue}
${milestoneId ? `**Sprint/Milestone:** ${sprint}` : ''}
${projectItems.length > 0 ? `**Adicionadas ao projeto:** ${projectItems.length} de ${createdIssues.length}` : ''}`;

              // Adicionar o checklist ao final do corpo da issue original
              const updatedBody = body + '\n\n' + statusSummary;

              await github.rest.issues.update({
                owner,
                repo,
                issue_number: parentNumber,
                body: updatedBody
              });

              // Adicionar comentÃ¡rio com resumo
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: parentNumber,
                body: `ðŸŽ¯ **Sub-issues criadas com sucesso!**

âœ… **${createdIssues.length}** sub-issues criadas
ðŸ“‚ **Tipo:** ${tipoSubIssue}
ðŸ·ï¸ **Labels aplicadas:** ${labels.join(', ')}
${milestoneId ? `ðŸŽ¯ **Milestone:** ${sprint}` : ''}
${projectItems.length > 0 ? `ðŸ“Š **Projeto:** ${projectItems.length} issues adicionadas ao GitHub Projects` : ''}

### ðŸ“ Sub-issues criadas:
${createdIssues.map(item => `- #${item.number} - [${item.title}](${item.url})`).join('\n')}

> ðŸ’¡ **Dica:** Marque os checkboxes no Story conforme as sub-issues forem sendo concluÃ­das!`
              });

              console.log(`Story atualizado com ${createdIssues.length} sub-issues criadas`);
            }